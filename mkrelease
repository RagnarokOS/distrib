#!/usr/bin/env perl

# $Ragnarok$

use strict;
use warnings;
use Config::General;
use Cwd;
use File::chdir;

my $conffile	= $ARGV[0];

my $conf = Config::General->new(
	-ConfigFile		=> $conffile,
	-SplitPolicy		=> 'custom',
	-SplitDelimiter		=> '\s+=\s+',
	-InterPolateVars	=> 1,
	-AutoTrue		=> 1
);

my %config	= $conf->getall;
my $workdir	= $config{'SRC_DIR'};
my $version	= $config{'VERSION'};
my $stage3	= $config{'STAGE3'};
my $port_git	= $config{'PORTAGE_GIT'};
my $toolchain	= $config{'TOOLCHAIN'};
my $destdir	= $config{'DESTDIR'};
my $emergeopts	= $config{'EMERGE_OPTS'};
my $hookdir	= $config{'HOOK_DIR'};

## Subroutines

# Handle errors
sub err {
	my $error	= shift;
	$error		= "Error: $error";

	die("$error\n");
}

# Print message (just makes the code more readable, again).
sub msg {
	my $msg = shift;
	print("$msg\n");
}

# Call scripts/genmount.sh
sub mount {
	my ($target)	= @_;

	system("sh", "scripts/genmount.sh", "$target") == 0
		or err("Can't run genmount.sh against $target");
}

# Extract a stage 3, whether it's a Gentoo archive or miniroot.
# TODO: support multiple archive format.
sub extract {
	my ($tarball, $dir) = @_;

	system("/usr/bin/tar", "xpvf", "$tarball", "--xattrs-include='*.*'", "--numeric-owner", "-C", "$dir") == 0
		or err("Can't extract $tarball to $dir");
}

# Create stage tarball.
sub archive {
	my ($tarball, $tardir)	= @_;

	# Change to dir and create tarball.
	chdir("$tardir") or err("Can't change to testdir");
	system("/usr/bin/tar", "cpPJvf", "../$tarball", "--ignore-failed-read", "--xattrs-include='*.*'", "--numeric-owner", "-X", "../excludes.txt", ".") == 0
		or err("Can't extract $tarball to $tardir");
	# Make sure we're back to the working directory.
	chdir("$workdir") or err("Can't change to $workdir");
}

# Run hooks
sub runhooks {
	my ($stage) = @_;

	opendir($dir, $hookdir) or die("Cannot open $dir\n");
	my @files = readdir($dir);
	closedir($dir) or die("Cannot close $dir\n");

	@files = sort { $a cmp $b } @files;
	my @scripts = grep(/$stage/, @files);

	foreach my $script (@scripts) {
		if($script =~ /^\./ or -d "$dir/$script") {
			next;
		}
		if(-x "$dir/$script") {
			print("Running $script from $dir...\n");
			system("$dir/$script") == 0
				or die("Cannot run $script, exiting...\n");
		}
	}
}

# Copy files to the chroot using rsync (for now at least).
sub copy_files {
	my ($dir, $dest)	= @_;

	# Make sure the path provided by dir and dest ends in a slash.
	$dir	       .= '/' unless("$dir" =~ m{/$});
	$dest	       .= '/' unless("$dest" =~ m{/$});

	system("/usr/bin/rsync", "-Klrv", "$dir", "$dest") == 0
		or err("Cannot copy $dir to $dest");
}

sub chrootcmd {
	my ($target, $cmd)	= @_;

	system("/usr/bin/chroot", "$target", "/bin/bash", "-c", "source /etc/profile && $cmd") == 0
		or err("Can't execute $cmd in $target");
}

sub main {
	my @buildopts	= split(' ', $emergeopts);

	unless(-d "$destdir") {
		msg("Creating missing $destdir");
		mkdir("$destdir") or err("Can't create $destdir");
	}

	msg("Extracting $stage3 to $destdir");
	extract("$stage3", "$destdir");

	msg("Mounting necessary filesystems to $destdir");
	mount("$destdir");

	msg("Running miniroot hooks");
	runhooks("extract");

	msg("Copying portage.conf to $destdir");
	copy_files("$workdir/portage.conf/", "$destdir");

	msg("Running setup hooks");
	runhooks("setup");

	msg('Rebuilding @world inside the chroot');
	chrootcmd($destdir, "/usr/bin/emerge @buildopts \@world");

	# If this is a miniroot, create the tarball and exit.
	if($destdir =~ "miniroot") {
		msg("Cleaning up the chroot...");
		runhooks("clean");
		msg("Creating miniroot tarball");
		archive("$destdir.tar.xz", $destdir);
		exit(0);
	}

	msg("Copying extra config files");
	copy_files("$workdir/includes.preinst", "$destdir");

	msg("Running configure hooks");
	runhooks("configure");
}
