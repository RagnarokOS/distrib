#!/usr/bin/env perl

# $Ragnarok$

use strict;
use warnings;
use Config::General;
use Cwd;
use File::chdir;

my $conffile	= $ARGV[0];

my $conf = Config::General->new(
	-ConfigFile		=> $conffile,
	-MergeDuplicateOptions	=> 1,
	-IncludeRelative	=> 1,
	-UseApacheInclude	=> 1,
	-SplitPolicy		=> 'custom',
	-SplitDelimiter		=> '\s+=\s+',
	-InterPolateVars	=> 1,
	-AutoTrue		=> 1
);

my %config	= $conf->getall;
my $workdir	= $config{'SRC_DIR'};
my $version	= $config{'VERSION'};
my $stage3	= $config{'STAGE3'};
my $port_git	= $config{'PORTAGE_GIT'};
my $toolchain	= $config{'TOOLCHAIN'};
my $destdir	= $config{'CHROOT'};
my $emergeopts	= $config{'EMERGE_OPTS'};
my $hookdir	= $config{'HOOK_DIR'};
my $pkg_cache	= $config{'PKG_CACHE'};

## Subroutines

# Handle errors
sub err {
	my $error	= shift;
	$error		= "Error: $error";

	die("$error\n");
}

# Print message (just makes the code more readable, again).
sub msg {
	my $msg = shift;
	print("$msg\n");
}

# Call scripts/genmount.sh
sub mount {
	my ($target)	= @_;

	system("sh", "scripts/genmount.sh", "$target") == 0
		or err("Can't run genmount.sh against $target");
}

# Extract a stage 3, whether it's a Gentoo archive or miniroot.
# TODO: support multiple archive format.
sub extract {
	my ($tarball, $dir) = @_;

	system("/usr/bin/tar", "xpvf", "$tarball", "--xattrs-include='*.*'", "--numeric-owner", "-C", "$dir") == 0
		or err("Can't extract $tarball to $dir");
}

# Create stage tarball.
sub archive {
	my ($tarball, $tardir)	= @_;

	# Change to dir and create tarball.
	chdir("$tardir") or err("Can't change to testdir");
	system("/usr/bin/tar", "cpPJvf", "../$tarball", "--ignore-failed-read", "--xattrs-include='*.*'", "--numeric-owner", "-X", "../excludes.txt", ".") == 0
		or err("Can't extract $tarball to $tardir");
	# Make sure we're back to the working directory.
	chdir("$workdir") or err("Can't change to $workdir");
}

# Run hooks
sub runhooks {
	my ($stage) = @_;

	opendir($dir, $hookdir) or die("Cannot open $dir\n");
	my @files = readdir($dir);
	closedir($dir) or die("Cannot close $dir\n");

	@files = sort { $a cmp $b } @files;
	my @scripts = grep(/$stage/, @files);

	foreach my $script (@scripts) {
		if($script =~ /^\./ or -d "$dir/$script") {
			next;
		}
		if(-x "$dir/$script") {
			print("Running $script from $dir...\n");
			system("$dir/$script", "$destdir") == 0
				or die("Cannot run $script, exiting...\n");
		}
	}
}

# Copy files to the chroot using rsync (for now at least).
sub copy_files {
	my ($dir, $dest)	= @_;

	# Make sure the path provided by dir and dest ends in a slash.
	$dir	       .= '/' unless("$dir" =~ m{/$});
	$dest	       .= '/' unless("$dest" =~ m{/$});

	system("/usr/bin/rsync", "-Klrv", "$dir", "$dest") == 0
		or err("Cannot copy $dir to $dest");
}

# TODO: use perl's built-in chroot instead of using system().
sub chrootcmd {
	my ($target, $cmd)	= @_;

	system("/usr/bin/chroot", "$target", "/bin/bash", "-c", "source /etc/profile && $cmd") == 0
		or err("Can't execute $cmd in $target");
}

sub binpkgs {
	# Only extract/copy binpkgs if binpkgs.tar.xz exists, fail otherwise.
	if (-e 'binpkgs.tar.xz') {
		extract("binpkgs.tar.xz", "$workdir");
		copy_files("binpkgs/", "$destdir/var/cache/binpkgs/");
		chrootcmd("$destdir", "emaint -f binhost");
	} else {
		msg("No binpkgs.tar.xz found. Exiting...");
		exit(1);
	}
}

# Install an alt. toolchain.
sub toolchain {
#	extract("toolchain.tgz", "$workdir");
#	copy_files("toolchain/", "$destdir/var/cache/binpkgs/");
#	chrootcmd("$destdir", "emaint -f binhost");
	chrootcmd("$destdir", "emerge -v --usepkg llvm-core/clang");
	chrootcmd("$destdir", "emerge -v --usepkg binutils gcc glibc");
	chrootcmd("$destdir", 'emerge -v --usepkg @llvm-toolchain');
	chrootcmd("$destdir", 'emerge -v --usepkg @build');
}

# Configure portage with git if PORTAGE_GIT is true.
sub portage_git {
#	extract("portage-git.tgz", "$workdir");
#	copy_files("portage-git/", "$destdir/var/cache/binpkgs/");
#	chrootcmd("$destdir", "emaint -f binhost");
	chrootcmd("$destdir", "emerge -v --usepkg app-eselect/eselect-repository dev-vcs/git");
	chrootcmd("$destdir", "rm -r /var/db/repos/gentoo");
	chrootcmd("$destdir", "emerge --sync");
}

sub pkg_cache {
	my ($archive)	= @_;

	system('/usr/bin/tar', 'cJvf', "$archive", '-C', "$destdir/var/cache/binpkgs", '.') == 0
		or err("Can't create binpkgs tarball");
}

sub main {
	my @buildopts	= split(' ', $emergeopts);

	unless(-d "$destdir") {
		msg("Creating missing $destdir");
		mkdir("$destdir") or err("Can't create $destdir");
	}

	msg("Extracting $stage3 to $destdir");
	extract("$stage3", "$destdir");

	msg("Mounting necessary filesystems to $destdir");
	mount("$destdir");

	msg("Running miniroot hooks");
	runhooks("extract");

	msg("Copying portage.conf to $destdir");
	copy_files("$workdir/portage.conf/", "$destdir");

	if ("$pkg_cache" eq "true") {
		binpkgs();
	}

	if("$toolchain" eq "true") {
		toolchain();
	}

	if("$port_git" eq "true") {
		portage_git();
	}

	msg("Running setup hooks");
	runhooks("setup");

	# If this is a miniroot, rebuild @world and create the tarball and exit.
	if($destdir =~ "miniroot") {
		msg('Rebuilding @world inside the chroot');
		chrootcmd($destdir, "/usr/bin/emerge @buildopts \@world");
		msg("Cleaning up the chroot...");
		runhooks("clean");
		msg("Creating miniroot tarball");
		archive("$destdir.tar.xz", $destdir);
		exit(0);
	}

	if (-d "$workdir/includes.preinst") {
		msg("Copying includes.preinst to the chroot");
		copy_files("$workdir/includes.preinst", "$destdir");
	}
	
	msg('Rebuilding @world inside the chroot');
	chrootcmd($destdir, "/usr/bin/emerge @buildopts \@world");

	if (-d "$workdir/includes.postinst") {
		msg("Copying includes.postinst to the chroot");
		copy_files("$workdir/includes.postinst", "$destdir");
	}

	msg("Running configure hooks");
	runhooks("configure");

	if ($pkg_cache eq "true") {
		pkg_cache("$workdir/binpkgs.tar.xz");
	}

}
